name: Build

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write

jobs:
  validate-scripts:
    name: Validate PowerShell Scripts
    runs-on: windows-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate PowerShell script syntax
        run: |
          $scripts = @(
            "src/main/resources/scripts/Gaming optimizations/Gaming-Optimizations.ps1",
            "src/main/resources/scripts/Network optimizations/Network-Optimizations.ps1",
            "src/main/resources/scripts/General Tweaks/General-Tweaks.ps1",
            "src/main/resources/scripts/Privacy Security/privacy.ps1",
            "src/main/resources/scripts/Privacy Security/security.ps1",
            "src/main/resources/scripts/Services management/Services-Management.ps1",
            "src/main/resources/scripts/Privacy Security/revert-privacy.ps1",
            "src/main/resources/scripts/Privacy Security/revert-security.ps1",
            "src/main/resources/scripts/Gaming optimizations/revert-gaming.ps1",
            "src/main/resources/scripts/General Tweaks/revert-general.ps1",
            "src/main/resources/scripts/Network optimizations/revert-network.ps1",
            "src/main/resources/scripts/Services management/revert-services.ps1",
            "src/main/resources/scripts/create_restore_point.ps1",
            "src/main/resources/scripts/CommonFunctions.ps1"
          )

          $errors = 0
          foreach ($script in $scripts) {
            if (Test-Path $script) {
              Write-Host "Validating: $script"
              $parseErrors = $null
              $tokens = $null
              [void][System.Management.Automation.Language.Parser]::ParseFile($script, [ref]$tokens, [ref]$parseErrors)
              if ($parseErrors.Count -gt 0) {
                Write-Error "Syntax error in $script"
                $parseErrors | ForEach-Object { Write-Error $_.Message }
                $errors++
              } else {
                Write-Host "Syntax OK: $script"
              }
            } else {
              Write-Error "Script not found: $script"
              $errors++
            }
          }

          if ($errors -gt 0) {
            exit 1
          }
        shell: pwsh

      - name: Verify script parameters and structure
        run: |
          $scripts = @(
            "src/main/resources/scripts/Gaming optimizations/Gaming-Optimizations.ps1",
            "src/main/resources/scripts/Network optimizations/Network-Optimizations.ps1",
            "src/main/resources/scripts/General Tweaks/General-Tweaks.ps1",
            "src/main/resources/scripts/Privacy Security/privacy.ps1",
            "src/main/resources/scripts/Privacy Security/security.ps1",
            "src/main/resources/scripts/Services management/Services-Management.ps1"
          )

          foreach ($script in $scripts) {
            Write-Host "Checking: $script"
            $content = Get-Content $script -Raw

            # Verify Action parameter (param block + [string]$Action)
            if ($content -notmatch 'param\s*\(' -or $content -notmatch '\[string\]\$Action') {
              Write-Error "Missing -Action parameter in $script"
              exit 1
            }

            # Verify version metadata
            if ($content -notmatch '\$script:ScriptVersion') {
              Write-Error "Missing version metadata in $script"
              exit 1
            }

            # Verify logging function available (defined locally or via CommonFunctions.ps1)
            if ($content -notmatch 'function Write-PTWLog' -and $content -notmatch 'CommonFunctions\.ps1') {
              Write-Error "Missing Write-PTWLog function or CommonFunctions.ps1 import in $script"
              exit 1
            }

            # Verify NO Read-Host (non-interactive) — (?m) makes ^ match start of each line
            if ($content -match '(?m)^\s*Read-Host' -and $content -notmatch '(?m)^\s*#.*Read-Host') {
              Write-Error "Script should be non-interactive (no Read-Host): $script"
              exit 1
            }

            Write-Host "Structure OK: $script"
          }
        shell: pwsh

      - name: Verify index.txt
        run: |
          $indexFile = "src/main/resources/scripts/index.txt"
          $scriptsDir = "src/main/resources/scripts"
          if (-not (Test-Path $indexFile)) {
            Write-Error "index.txt not found"
            exit 1
          }

          $indexContent = Get-Content $indexFile
          $requiredFiles = @(
            "Gaming optimizations/Gaming-Optimizations.ps1",
            "Network optimizations/Network-Optimizations.ps1",
            "General Tweaks/General-Tweaks.ps1",
            "Privacy Security/privacy.ps1",
            "Privacy Security/security.ps1",
            "Services management/Services-Management.ps1",
            "Privacy Security/revert-privacy.ps1",
            "Privacy Security/revert-security.ps1",
            "create_restore_point.ps1",
            "CommonFunctions.ps1"
          )

          foreach ($required in $requiredFiles) {
            if ($indexContent -notcontains $required) {
              Write-Error "Missing entry in index.txt: $required"
              exit 1
            }
          }

          # Reverse check: every entry in index.txt must correspond to a real file
          foreach ($entry in $indexContent) {
            $trimmed = $entry.Trim()
            if (-not $trimmed) { continue }
            $fullPath = Join-Path $scriptsDir $trimmed
            if (-not (Test-Path $fullPath)) {
              Write-Error "index.txt references non-existent file: $trimmed"
              exit 1
            }
          }

          Write-Host "index.txt validation passed"
        shell: pwsh

  security-scan:
    name: Security Scan
    runs-on: windows-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for obfuscated code
        run: |
          Write-Host "Scanning for obfuscated code patterns..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $obfuscationPatterns = @(
            'RunAsTI',
            'TrustedInstaller.*powershell',
            'iex\s*\(.*env:',
            'Invoke-Expression.*\$env',
            '\[System\.Reflection\.Assembly\]::LoadWithPartialName.*obfuscat',
            'base64.*decode',
            'FromBase64String'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw

            foreach ($pattern in $obfuscationPatterns) {
              if ($content -match $pattern) {
                Write-Warning "Potential obfuscation pattern found in $($script.Name)`: $pattern"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues potential obfuscation patterns. Please review."
            exit 1
          } else {
            Write-Host "[+] No obfuscated code patterns detected"
          }
        shell: pwsh

      - name: Check for Windows Update disabling
        run: |
          Write-Host "Scanning for Windows Update disabling functionality..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $updateDisablePatterns = @(
            'WindowsUpdate.*disable|Disable.*WindowsUpdate',
            'WUServer|WUStatusServer',
            'UpdateServiceUrl',
            'fuckyoumicrosoft',
            'LGPO.*update|update.*LGPO',
            'DisableUpdates|EnableUpdates',
            'PreventWinUpdate.*True',
            'SearchOrderConfig.*0.*driver.*update'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw -ErrorAction SilentlyContinue

            foreach ($pattern in $updateDisablePatterns) {
              if ($content -match $pattern) {
                Write-Error "Windows Update disabling pattern found in $($script.Name)`: $pattern"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues Windows Update disabling patterns. These must be removed."
            exit 1
          } else {
            Write-Host "[+] No Windows Update disabling patterns detected"
          }
        shell: pwsh

      - name: Check for security feature disabling
        run: |
          Write-Host "Scanning for security feature disabling..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $securityDisablePatterns = @(
            'Windows.*Defender.*disable|Disable.*Windows.*Defender',
            'SmartScreen.*disable|Disable.*SmartScreen',
            'Firewall.*disable|Disable.*Firewall',
            'UAC.*disable|Disable.*UAC',
            'SecurityHealthService.*disable',
            'Set-MpPreference.*DisableRealtimeMonitoring',
            'Set-MpPreference.*DisableBehaviorMonitoring',
            'Set-MpPreference.*DisableIOAVProtection',
            'Set-MpPreference.*DisableScriptScanning',
            'Set-MpPreference.*DisableBlockAtFirstSeen',
            'Set-MpPreference.*DisablePrivacyMode',
            'Set-MpPreference.*DisableArchiveScanning',
            'Set-MpPreference.*DisableIntrusionPreventionSystem',
            'Set-MpPreference.*DisableNetworkProtection'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw -ErrorAction SilentlyContinue

            foreach ($pattern in $securityDisablePatterns) {
              if ($content -match $pattern) {
                Write-Error "Security feature disabling pattern found in $($script.Name)`: $pattern"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues security feature disabling patterns. These must be removed."
            exit 1
          } else {
            Write-Host "[+] No security feature disabling patterns detected"
          }
        shell: pwsh

      - name: Check for suspicious network calls
        run: |
          Write-Host "Scanning for suspicious network calls..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $allowedDomains = @(
            'github.com',
            'microsoft.com',
            'githubusercontent.com',
            'oo-software.com',
            'geforce.com',
            'nvidia.com',
            '7-zip.org'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw -ErrorAction SilentlyContinue

            # Extract URLs
            $urlMatches = [regex]::Matches($content, 'https?://[^\s''"`]+')
            foreach ($match in $urlMatches) {
              $url = $match.Value
              $isAllowed = $false

              # Parse the host from the URL and check against allowed domains
              try {
                $uri = [System.Uri]::new($url)
                $host_ = $uri.Host
                foreach ($domain in $allowedDomains) {
                  if ($host_ -eq $domain -or $host_.EndsWith(".$domain")) {
                    $isAllowed = $true
                    break
                  }
                }
              } catch {
                # Malformed URL — flag it
              }

              if (-not $isAllowed) {
                Write-Warning "Suspicious URL found in $($script.Name)`: $url"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Warning "Found $issues potentially suspicious network calls. Please review."
            # Don't fail, just warn - some legitimate downloads may exist
          } else {
            Write-Host "[+] No suspicious network calls detected"
          }
        shell: pwsh

      - name: Check for credential exposure
        run: |
          Write-Host "Scanning for exposed credentials..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $credentialPatterns = @(
            'password\s*=\s*["'']',
            'pwd\s*=\s*["'']',
            'passwd\s*=\s*["'']',
            'secret\s*=\s*["'']',
            'api[_-]?key\s*=\s*["'']',
            'token\s*=\s*["'']',
            'Authorization.*Bearer\s+[A-Za-z0-9]{20,}',
            'ConvertTo-SecureString.*-AsPlainText'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw -ErrorAction SilentlyContinue

            foreach ($pattern in $credentialPatterns) {
              if ($content -match $pattern) {
                Write-Warning "Potential credential exposure pattern found in $($script.Name)`: $pattern"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Warning "Found $issues potential credential exposure patterns. Please review."
            # Don't fail, just warn - some false positives may exist
          } else {
            Write-Host "[+] No credential exposure patterns detected"
          }
        shell: pwsh

      - name: Check for malicious registry modifications
        run: |
          Write-Host "Scanning for malicious registry modifications..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse

          $maliciousPatterns = @(
            'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run.*powershell.*hidden',
            'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run.*powershell.*hidden',
            'Startup.*powershell.*hidden',
            'reg.*add.*Run.*powershell.*-WindowStyle.*Hidden',
            'reg.*add.*Run.*cmd.*\/c.*powershell.*hidden'
          )

          $issues = 0
          foreach ($script in $scripts) {
            Write-Host "Scanning: $($script.FullName)"
            $content = Get-Content $script.FullName -Raw -ErrorAction SilentlyContinue

            foreach ($pattern in $maliciousPatterns) {
              if ($content -match $pattern) {
                Write-Error "Malicious registry modification pattern found in $($script.Name)`: $pattern"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues malicious registry modification patterns. These must be removed."
            exit 1
          } else {
            Write-Host "[+] No malicious registry modification patterns detected"
          }
        shell: pwsh

      - name: Scan for hardcoded secrets
        run: |
          Write-Host "Scanning for hardcoded secrets across repository..."

          $allFiles = Get-ChildItem -Path "." -Recurse -File |
            Where-Object {
              $_.Extension -in @('.ps1', '.java', '.xml', '.yml', '.yaml', '.json', '.properties', '.conf', '.cfg', '.bat', '.cmd', '.txt', '.md', '.env') -and
              $_.FullName -notmatch '[\\/](target|\.git|node_modules|\.idea)[\\/]'
            }

          Write-Host "Scanning $($allFiles.Count) files..."

          $secretPatterns = @(
            @{ Name = "GitHub Token";           Pattern = 'gh[pousr]_[A-Za-z0-9_]{36,}' },
            @{ Name = "Generic API Key";        Pattern = '(?i)(api[_-]?key|apikey)\s*[:=]\s*[''"][A-Za-z0-9\-_.]{20,}[''"]' },
            @{ Name = "Generic Secret";         Pattern = '(?i)(client[_-]?secret|secret[_-]?key)\s*[:=]\s*[''"][A-Za-z0-9\-_.]{20,}[''"]' },
            @{ Name = "Private Key";            Pattern = '-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----' }
          )

          $issues = 0
          foreach ($file in $allFiles) {
            $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
            if (-not $content) { continue }

            foreach ($sp in $secretPatterns) {
              if ($content -match $sp.Pattern) {
                $relativePath = $file.FullName -replace [regex]::Escape((Get-Location).Path + '\'), ''
                Write-Error "Potential $($sp.Name) found in: $relativePath"
                $issues++
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues potential hardcoded secrets. These must be removed or moved to GitHub Secrets."
            exit 1
          } else {
            Write-Host "[+] No hardcoded secrets detected"
          }
        shell: pwsh

      - name: Check for hardcoded Windows paths
        run: |
          Write-Host "Scanning for hardcoded user-specific Windows paths..."

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse
          $javaFiles = Get-ChildItem -Path "src/main/java" -Filter "*.java" -Recurse

          $pathPatterns = @(
            @{ Name = "Hardcoded user profile path"; Pattern = '[A-Za-z]:\\Users\\[^$\\{][A-Za-z0-9._-]+\\' },
            @{ Name = "Hardcoded Program Files path"; Pattern = '[A-Za-z]:\\Program Files( \(x86\))?\\[A-Za-z]' },
            @{ Name = "Hardcoded temp path";          Pattern = '[A-Za-z]:\\[Tt]emp\\' }
          )

          # Patterns that are OK (environment variable usage)
          $allowedPatterns = @(
            '\$env:',
            '\$Env:',
            '\[Environment\]',
            '%USERPROFILE%',
            '%PROGRAMFILES%',
            '%TEMP%',
            '%APPDATA%'
          )

          $issues = 0
          foreach ($file in ($scripts + $javaFiles)) {
            $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
            if (-not $content) { continue }

            foreach ($pp in $pathPatterns) {
              $matches = [regex]::Matches($content, $pp.Pattern)
              foreach ($m in $matches) {
                # Check the line containing the match for allowed env var usage
                $lineStart = $content.LastIndexOf("`n", [Math]::Max(0, $m.Index - 1)) + 1
                $lineEnd = $content.IndexOf("`n", $m.Index)
                if ($lineEnd -eq -1) { $lineEnd = $content.Length }
                $line = $content.Substring($lineStart, $lineEnd - $lineStart).Trim()

                $isAllowed = $false
                foreach ($ap in $allowedPatterns) {
                  if ($line -match $ap) { $isAllowed = $true; break }
                }

                # Skip comments
                if ($line -match '^\s*#' -or $line -match '^\s*//') { $isAllowed = $true }

                if (-not $isAllowed) {
                  $relativePath = $file.FullName -replace [regex]::Escape((Get-Location).Path + '\'), ''
                  Write-Error "$($pp.Name) in $relativePath`: $($m.Value)"
                  $issues++
                }
              }
            }
          }

          if ($issues -gt 0) {
            Write-Error "Found $issues hardcoded paths. Use environment variables (`$env:USERPROFILE, `$env:PROGRAMFILES, `$env:TEMP) instead."
            exit 1
          } else {
            Write-Host "[+] No hardcoded Windows paths detected"
          }
        shell: pwsh

  functional-testing:
    name: Functional Testing
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache PSScriptAnalyzer module
        uses: actions/cache@v4
        with:
          path: ~/Documents/PowerShell/Modules/PSScriptAnalyzer
          key: psscriptanalyzer-windows-latest

      - name: Run PSScriptAnalyzer
        run: |
          if (-not (Get-Module -ListAvailable -Name PSScriptAnalyzer)) {
            Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
          }

          $scripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse
          Write-Host "Analyzing $($scripts.Count) PowerShell scripts..."

          $excludeRules = @(
            'PSAvoidUsingWriteHost',
            'PSUseShouldProcessForStateChangingFunctions',
            'PSAvoidGlobalVars'
          )

          $errors = 0
          $warnings = 0

          foreach ($script in $scripts) {
            $results = Invoke-ScriptAnalyzer -Path $script.FullName -ExcludeRule $excludeRules -Severity @('Error', 'Warning')

            foreach ($result in $results) {
              $shortPath = $script.FullName -replace '.*src\\main\\resources\\', ''
              if ($result.Severity -eq 'Error') {
                Write-Error "[$($result.Severity)] $shortPath`:$($result.Line) - $($result.RuleName): $($result.Message)"
                $errors++
              } else {
                Write-Warning "[$($result.Severity)] $shortPath`:$($result.Line) - $($result.RuleName): $($result.Message)"
                $warnings++
              }
            }
          }

          Write-Host ""
          Write-Host "[*] PSScriptAnalyzer: $errors errors, $warnings warnings"

          if ($errors -gt 0) {
            Write-Error "PSScriptAnalyzer found $errors errors. Fix before merging."
            exit 1
          }

          Write-Host "[+] PSScriptAnalyzer passed"
        shell: pwsh

      - name: Verify non-interactive script architecture
        run: |
          Write-Host "Testing non-interactive action dispatcher architecture..."

          $scripts = @(
            "src/main/resources/scripts/Gaming optimizations/Gaming-Optimizations.ps1",
            "src/main/resources/scripts/Network optimizations/Network-Optimizations.ps1",
            "src/main/resources/scripts/General Tweaks/General-Tweaks.ps1",
            "src/main/resources/scripts/Privacy Security/privacy.ps1",
            "src/main/resources/scripts/Privacy Security/security.ps1",
            "src/main/resources/scripts/Services management/Services-Management.ps1"
          )

          foreach ($scriptPath in $scripts) {
            Write-Host "Testing: $scriptPath"
            $content = Get-Content $scriptPath -Raw

            # Verify Action parameter (param block + [string]$Action)
            if ($content -notmatch 'param\s*\(' -or $content -notmatch '\[string\]\$Action') {
              Write-Error "Missing -Action parameter in $scriptPath"
              exit 1
            }

            # Verify switch dispatcher
            if ($content -notmatch 'switch\s*\(\$Action') {
              Write-Error "Missing switch dispatcher in $scriptPath"
              exit 1
            }

            # Verify NO Show-MainMenu (non-interactive)
            if ($content -match 'function\s+Show-MainMenu') {
              Write-Error "Script should not have Show-MainMenu (non-interactive): $scriptPath"
              exit 1
            }

            # Verify version metadata
            if ($content -notmatch '\$script:ScriptVersion') {
              Write-Error "Missing version metadata in $scriptPath"
              exit 1
            }

            # Verify NO Read-Host (non-interactive) — (?m) makes ^ match start of each line
            if ($content -match '(?m)^\s*Read-Host') {
              Write-Error "Script should be non-interactive (no Read-Host): $scriptPath"
              exit 1
            }

            Write-Host "[+] $scriptPath validated"
          }

          Write-Host "[+] All scripts have correct non-interactive architecture"
        shell: pwsh

      - name: Verify Java action IDs match PowerShell cases
        run: |
          Write-Host "Verifying Java action IDs match PowerShell switch cases..."

          $javaFile = "src/main/java/com/zl/pleasetweakwindows/TweakController.java"
          $javaContent = Get-Content $javaFile -Raw

          # Extract action IDs from Java (exclude revert IDs - handled by revert scripts)
          $javaActions = [regex]::Matches($javaContent, '"([a-z][a-z0-9]+-[a-z0-9-]+)"') |
            ForEach-Object { $_.Groups[1].Value } |
            Where-Object { $_ -notmatch '-revert$' } |
            Sort-Object -Unique

          Write-Host "Found $($javaActions.Count) non-revert action IDs in Java"

          # Get all PS scripts content (excluding revert scripts, CommonFunctions, restore point)
          $psScripts = Get-ChildItem -Path "src/main/resources/scripts" -Filter "*.ps1" -Recurse |
            Where-Object { $_.Name -notlike "revert-*" -and $_.Name -ne "CommonFunctions.ps1" -and $_.Name -ne "create_restore_point.ps1" }

          $psContent = $psScripts | ForEach-Object { Get-Content $_.FullName -Raw } | Out-String

          $missing = @()
          foreach ($action in $javaActions) {
            if ($psContent -notmatch "`"$action`"") {
              $missing += $action
            }
          }

          if ($missing.Count -gt 0) {
            Write-Error "Missing PowerShell handlers for actions: $($missing -join ', ')"
            exit 1
          }

          Write-Host "[+] All $($javaActions.Count) non-revert Java action IDs have PowerShell handlers"
        shell: pwsh

      - name: Test create_restore_point script
        run: |
          $scriptPath = "src/main/resources/scripts/create_restore_point.ps1"
          Write-Host "Testing create_restore_point script..."

          $testScript = @"
          `$ErrorActionPreference = 'Stop'
          try {
              if (-not (Test-Path '$scriptPath')) {
                  throw "Script not found: $scriptPath"
              }

              `$scriptContent = Get-Content '$scriptPath' -Raw

              # Verify it has param block
              if (`$scriptContent -notmatch 'param\s*\(') {
                  throw "Missing param block"
              }

              # Verify it uses Checkpoint-Computer or similar
              if (`$scriptContent -notmatch 'Checkpoint-Computer|RestorePoint') {
                  throw "Missing restore point creation logic"
              }

              # Syntax validation
              `$null = [System.Management.Automation.PSParser]::Tokenize(`$scriptContent, [ref]`$null)

              Write-Host "[+] create_restore_point script validated"

          } catch {
              Write-Error "create_restore_point script test failed: `$(`$_.Exception.Message)"
              exit 1
          }
          "@

          powershell -NoProfile -Command $testScript
        shell: pwsh

      - name: Test revert scripts structure
        run: |
          Write-Host "Testing revert scripts structure..."

          $revertScripts = @(
            "src/main/resources/scripts/Privacy Security/revert-privacy.ps1",
            "src/main/resources/scripts/Privacy Security/revert-security.ps1",
            "src/main/resources/scripts/Gaming optimizations/revert-gaming.ps1",
            "src/main/resources/scripts/General Tweaks/revert-general.ps1",
            "src/main/resources/scripts/Network optimizations/revert-network.ps1",
            "src/main/resources/scripts/Services management/revert-services.ps1"
          )

          foreach ($scriptPath in $revertScripts) {
            Write-Host "Testing: $scriptPath"
            $content = Get-Content $scriptPath -Raw

            # Verify Mode parameter
            if ($content -notmatch '\[string\]\$Mode') {
              Write-Error "Missing Mode parameter in $scriptPath"
              exit 1
            }

            # Verify PTW_EMBEDDED handling (directly or via CommonFunctions.ps1)
            if ($content -notmatch 'PTW_EMBEDDED' -and $content -notmatch 'CommonFunctions\.ps1') {
              Write-Error "Missing PTW_EMBEDDED handling in $scriptPath"
              exit 1
            }

            # Verify admin check
            if ($content -notmatch '#Requires -RunAsAdministrator') {
              Write-Error "Missing admin requirement in $scriptPath"
              exit 1
            }

            # Verify version metadata
            if ($content -notmatch '\$script:ScriptVersion') {
              Write-Error "Missing version metadata in $scriptPath"
              exit 1
            }

            # Syntax check
            $parseErrors = $null
            [void][System.Management.Automation.Language.Parser]::ParseFile($scriptPath, [ref]$null, [ref]$parseErrors)
            if ($parseErrors.Count -gt 0) {
              Write-Error "Syntax errors in $scriptPath"
              exit 1
            }

            Write-Host "[+] $scriptPath validated"
          }

          Write-Host "[+] All revert scripts have correct structure"
        shell: pwsh

  build-exe:
    name: Build Windows EXE
    runs-on: windows-latest
    needs: [validate-scripts, security-scan, functional-testing]
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Liberica NIK
        uses: graalvm/setup-graalvm@v1
        with:
          distribution: 'liberica'
          java-version: '21'
          java-package: 'jdk+fx'
          github-token: ${{ secrets.GITHUB_TOKEN }}
          cache: 'maven'

      - name: Run tests
        run: mvn test

      - name: Compile Windows resources (icon + manifest)
        run: |
          $rcExe = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "rc.exe" |
            Where-Object { $_.FullName -match 'x64' } |
            Sort-Object { [version]($_.FullName -replace '.*\\(\d+\.\d+\.\d+\.\d+)\\.*','$1') } -Descending |
            Select-Object -First 1
          if (-not $rcExe) {
            Write-Error "rc.exe not found in Windows SDK"
            exit 1
          }
          Write-Host "Using: $($rcExe.FullName)"
          Push-Location src/main/resources/native
          & $rcExe.FullName /nologo app.rc
          if ($LASTEXITCODE -ne 0) { exit 1 }
          Pop-Location
          Write-Host "[+] app.res compiled successfully"
        shell: pwsh

      - name: Build EXE
        run: mvn -Pnative package

      - name: Verify EXE exists
        run: |
          if (Test-Path "target/PleaseTweakWindows.exe") {
            Write-Host "[+] EXE file found at target/PleaseTweakWindows.exe"
            $fileInfo = Get-Item "target/PleaseTweakWindows.exe"
            Write-Host "File size: $([math]::Round($fileInfo.Length / 1MB, 1)) MB ($($fileInfo.Length) bytes)"
          } else {
            Write-Error "[-] EXE file not found at target/PleaseTweakWindows.exe"
            Write-Host "Build may have failed or the output path is different."
            exit 1
          }
        shell: pwsh

      - name: Verify scripts are included in resources
        run: |
          $requiredScripts = @(
            "Gaming optimizations/Gaming-Optimizations.ps1",
            "Network optimizations/Network-Optimizations.ps1",
            "General Tweaks/General-Tweaks.ps1",
            "Privacy Security/privacy.ps1",
            "Privacy Security/security.ps1",
            "Privacy Security/revert-privacy.ps1",
            "Privacy Security/revert-security.ps1",
            "Services management/Services-Management.ps1",
            "create_restore_point.ps1"
          )
          $requiredRegFiles = @(
            "General Tweaks/regs/Registry-Optimize.reg",
            "General Tweaks/regs/Registry-Defaults.reg"
          )

          $scriptsDir = "src/main/resources/scripts"
          foreach ($script in $requiredScripts) {
            $fullPath = Join-Path $scriptsDir $script
            if (-not (Test-Path $fullPath)) {
              Write-Error "Required script not found: $fullPath"
              exit 1
            }
            Write-Host "Verified: $script"
          }
          foreach ($regFile in $requiredRegFiles) {
            $fullPath = Join-Path $scriptsDir $regFile
            if (-not (Test-Path $fullPath)) {
              Write-Error "Required reg file not found: $fullPath"
              exit 1
            }
            Write-Host "Verified: $regFile"
          }
          Write-Host "All required scripts and reg files are present"
        shell: pwsh

      - name: Upload EXE artifact
        uses: actions/upload-artifact@v4
        with:
          name: please-tweak-windows-exe
          path: target/PleaseTweakWindows.exe

  create-release:
    name: Create Release
    runs-on: windows-latest
    needs: build-exe
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next version
        id: version
        run: |
          $tags = git tag -l "v*" --sort=-v:refname 2>$null
          if ($tags) {
            $latest = ($tags | Select-Object -First 1)
            Write-Host "Latest tag: $latest"
            if ($latest -match '^v(\d+)\.(\d+)\.(\d+)$') {
              $major = [int]$Matches[1]
              $minor = [int]$Matches[2]
              $patch = [int]$Matches[3] + 1
              $next = "v$major.$minor.$patch"
            } else {
              $next = "v1.0.0"
            }
          } else {
            $next = "v1.0.0"
          }
          Write-Host "Next version: $next"
          "version=$next" | Out-File -Append $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Download EXE artifact
        uses: actions/download-artifact@v4
        with:
          name: please-tweak-windows-exe
          path: ./artifacts

      - name: Create distribution package
        run: |
          if (Test-Path "dist") { Remove-Item -Recurse -Force "dist" }
          New-Item -ItemType Directory -Path "dist" | Out-Null
          Copy-Item "./artifacts/PleaseTweakWindows.exe" "dist/"
          Copy-Item "README.md" "dist/"
          if (Test-Path "LICENSE") {
            Copy-Item "LICENSE" "dist/"
          } else {
            Write-Warning "LICENSE file not found — release will ship without it"
          }
          Copy-Item -Recurse "src/main/resources/scripts" "dist/"
          New-Item -ItemType Directory -Path "dist/logs" | Out-Null
          Copy-Item "logs/README.txt" "dist/logs/" -ErrorAction SilentlyContinue

          # Remove unused revert scripts from distribution
          Remove-Item "dist/scripts/Gaming optimizations/revert-gaming.ps1" -ErrorAction SilentlyContinue
          Remove-Item "dist/scripts/General Tweaks/revert-general.ps1" -ErrorAction SilentlyContinue
          Remove-Item "dist/scripts/Network optimizations/revert-network.ps1" -ErrorAction SilentlyContinue
          Remove-Item "dist/scripts/Services management/revert-services.ps1" -ErrorAction SilentlyContinue

          # Verify all scripts are included
          $scriptCount = (Get-ChildItem -Path "dist/scripts" -Recurse -Filter "*.ps1" -File).Count
          Write-Host "Included PowerShell scripts: $scriptCount"

          if ($scriptCount -lt 5) {
            Write-Error "Expected at least 5 PowerShell scripts, found $scriptCount"
            exit 1
          }

          # Verify required reg files are included
          $requiredRegFiles = @(
            "General Tweaks/regs/Registry-Optimize.reg",
            "General Tweaks/regs/Registry-Defaults.reg"
          )
          foreach ($regFile in $requiredRegFiles) {
            $fullPath = Join-Path "dist/scripts" $regFile
            if (-not (Test-Path $fullPath)) {
              Write-Error "Required reg file missing from dist: $fullPath"
              exit 1
            }
            Write-Host "Verified reg file in dist: $regFile"
          }

          # Create ZIP file using PowerShell
          Compress-Archive -Path "dist/*" -DestinationPath "PleaseTweakWindows.zip" -Force

          # Verify ZIP was created
          if (Test-Path "PleaseTweakWindows.zip") {
            $zipInfo = Get-Item "PleaseTweakWindows.zip"
            Write-Host "Distribution package created: $($zipInfo.Length) bytes"
          } else {
            Write-Error "Failed to create distribution package"
            exit 1
          }
        shell: pwsh

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: PleaseTweakWindows ${{ steps.version.outputs.version }}
          files: PleaseTweakWindows.zip
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
